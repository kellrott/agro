// Code generated by protoc-gen-go.
// source: proto/agro.proto
// DO NOT EDIT!

/*
Package agro_pb is a generated protocol buffer package.

It is generated from these files:
	proto/agro.proto

It has these top-level messages:
	Task
	Job
	JobStatus
	TaskStatus
	TaskRequirement
	CmdArgument
	FileArgument
	WorkerInfo
	TagArray
	IDQuery
	UpdateStateRequest
	JobLog
	JobRequest
	DataBlock
	FileInfo
	Field
	Document
	FileID
	FileState
	ReadRequest
*/
package agro_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// *
// The different states a job or a task can be in
type State int32

const (
	State_ERROR   State = 0
	State_WAITING State = 1
	State_READY   State = 2
	State_PAUSED  State = 3
	State_QUEUED  State = 4
	State_RUNNING State = 5
	State_OK      State = 6
)

var State_name = map[int32]string{
	0: "ERROR",
	1: "WAITING",
	2: "READY",
	3: "PAUSED",
	4: "QUEUED",
	5: "RUNNING",
	6: "OK",
}
var State_value = map[string]int32{
	"ERROR":   0,
	"WAITING": 1,
	"READY":   2,
	"PAUSED":  3,
	"QUEUED":  4,
	"RUNNING": 5,
	"OK":      6,
}

func (x State) Enum() *State {
	p := new(State)
	*p = x
	return p
}
func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (x *State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(State_value, data, "State")
	if err != nil {
		return err
	}
	*x = State(value)
	return nil
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type FileArgument_FileArgType int32

const (
	FileArgument_PATH   FileArgument_FileArgType = 1
	FileArgument_NAMED  FileArgument_FileArgType = 2
	FileArgument_REGEX  FileArgument_FileArgType = 3
	FileArgument_STDOUT FileArgument_FileArgType = 4
	FileArgument_STDERR FileArgument_FileArgType = 5
	FileArgument_STDIN  FileArgument_FileArgType = 6
)

var FileArgument_FileArgType_name = map[int32]string{
	1: "PATH",
	2: "NAMED",
	3: "REGEX",
	4: "STDOUT",
	5: "STDERR",
	6: "STDIN",
}
var FileArgument_FileArgType_value = map[string]int32{
	"PATH":   1,
	"NAMED":  2,
	"REGEX":  3,
	"STDOUT": 4,
	"STDERR": 5,
	"STDIN":  6,
}

func (x FileArgument_FileArgType) Enum() *FileArgument_FileArgType {
	p := new(FileArgument_FileArgType)
	*p = x
	return p
}
func (x FileArgument_FileArgType) String() string {
	return proto.EnumName(FileArgument_FileArgType_name, int32(x))
}
func (x *FileArgument_FileArgType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FileArgument_FileArgType_value, data, "FileArgument_FileArgType")
	if err != nil {
		return err
	}
	*x = FileArgument_FileArgType(value)
	return nil
}
func (FileArgument_FileArgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

// *
// The Task Record
// A task is a request for work to be done, it does not represent a specific
// invocation of that work. It is abstract, and describes the request and its
// dependencies. A Job represents a real instance of a Task, and there may be
// multiple jobs for associated with a single task.
type Task struct {
	Id               *string            `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	TaskDepends      []string           `protobuf:"bytes,2,rep,name=task_depends" json:"task_depends,omitempty"`
	Command          *string            `protobuf:"bytes,3,req,name=command" json:"command,omitempty"`
	Args             []*CmdArgument     `protobuf:"bytes,4,rep,name=args" json:"args,omitempty"`
	Container        *string            `protobuf:"bytes,5,opt,name=container" json:"container,omitempty"`
	Tags             []string           `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	Requirements     []*TaskRequirement `protobuf:"bytes,7,rep,name=requirements" json:"requirements,omitempty"`
	State            *State             `protobuf:"varint,8,opt,name=state,enum=agro_pb.State" json:"state,omitempty"`
	MaxRetry         *int32             `protobuf:"varint,9,opt,name=max_retry" json:"max_retry,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Task) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Task) GetTaskDepends() []string {
	if m != nil {
		return m.TaskDepends
	}
	return nil
}

func (m *Task) GetCommand() string {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return ""
}

func (m *Task) GetArgs() []*CmdArgument {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Task) GetContainer() string {
	if m != nil && m.Container != nil {
		return *m.Container
	}
	return ""
}

func (m *Task) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Task) GetRequirements() []*TaskRequirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *Task) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

func (m *Task) GetMaxRetry() int32 {
	if m != nil && m.MaxRetry != nil {
		return *m.MaxRetry
	}
	return 0
}

// *
// The Job Record
// A job is a specific instance of a Task, representing a real invocation the will
// be or has been run on the system.
type Job struct {
	Id               *string            `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	TaskId           *string            `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	Command          *string            `protobuf:"bytes,3,req,name=command" json:"command,omitempty"`
	Args             []*CmdArgument     `protobuf:"bytes,4,rep,name=args" json:"args,omitempty"`
	Container        *string            `protobuf:"bytes,5,opt,name=container" json:"container,omitempty"`
	Requirements     []*TaskRequirement `protobuf:"bytes,6,rep,name=requirements" json:"requirements,omitempty"`
	State            *State             `protobuf:"varint,7,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	Stdout           *string            `protobuf:"bytes,8,opt,name=stdout" json:"stdout,omitempty"`
	Stderr           *string            `protobuf:"bytes,9,opt,name=stderr" json:"stderr,omitempty"`
	Worker           *string            `protobuf:"bytes,10,opt,name=worker" json:"worker,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Job) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Job) GetTaskId() string {
	if m != nil && m.TaskId != nil {
		return *m.TaskId
	}
	return ""
}

func (m *Job) GetCommand() string {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return ""
}

func (m *Job) GetArgs() []*CmdArgument {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Job) GetContainer() string {
	if m != nil && m.Container != nil {
		return *m.Container
	}
	return ""
}

func (m *Job) GetRequirements() []*TaskRequirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *Job) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

func (m *Job) GetStdout() string {
	if m != nil && m.Stdout != nil {
		return *m.Stdout
	}
	return ""
}

func (m *Job) GetStderr() string {
	if m != nil && m.Stderr != nil {
		return *m.Stderr
	}
	return ""
}

func (m *Job) GetWorker() string {
	if m != nil && m.Worker != nil {
		return *m.Worker
	}
	return ""
}

// *
// Job Status information
type JobStatus struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	State            *State  `protobuf:"varint,2,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *JobStatus) Reset()                    { *m = JobStatus{} }
func (m *JobStatus) String() string            { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()               {}
func (*JobStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *JobStatus) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *JobStatus) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

// *
// Task status
type TaskStatus struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	State            *State   `protobuf:"varint,2,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	CompletedJob     *string  `protobuf:"bytes,3,opt,name=completed_job" json:"completed_job,omitempty"`
	Runs             []string `protobuf:"bytes,4,rep,name=runs" json:"runs,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TaskStatus) Reset()                    { *m = TaskStatus{} }
func (m *TaskStatus) String() string            { return proto.CompactTextString(m) }
func (*TaskStatus) ProtoMessage()               {}
func (*TaskStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TaskStatus) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *TaskStatus) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

func (m *TaskStatus) GetCompletedJob() string {
	if m != nil && m.CompletedJob != nil {
		return *m.CompletedJob
	}
	return ""
}

func (m *TaskStatus) GetRuns() []string {
	if m != nil {
		return m.Runs
	}
	return nil
}

// *
// Task requirements
// describes the requirements (mem, cpu count, diskspace) required for the task to be run
type TaskRequirement struct {
	// / Right now requirement is done as a string, to allow for customization
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TaskRequirement) Reset()                    { *m = TaskRequirement{} }
func (m *TaskRequirement) String() string            { return proto.CompactTextString(m) }
func (*TaskRequirement) ProtoMessage()               {}
func (*TaskRequirement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TaskRequirement) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TaskRequirement) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// CmdArgument
// The arguments to be passed into the running program are passed in as an array of
// strings or file arguments
type CmdArgument struct {
	// Types that are valid to be assigned to Value:
	//	*CmdArgument_Arg
	//	*CmdArgument_FileArg
	Value            isCmdArgument_Value `protobuf_oneof:"Value"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *CmdArgument) Reset()                    { *m = CmdArgument{} }
func (m *CmdArgument) String() string            { return proto.CompactTextString(m) }
func (*CmdArgument) ProtoMessage()               {}
func (*CmdArgument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isCmdArgument_Value interface {
	isCmdArgument_Value()
}

type CmdArgument_Arg struct {
	Arg string `protobuf:"bytes,1,opt,name=arg,oneof"`
}
type CmdArgument_FileArg struct {
	FileArg *FileArgument `protobuf:"bytes,2,opt,name=file_arg,oneof"`
}

func (*CmdArgument_Arg) isCmdArgument_Value()     {}
func (*CmdArgument_FileArg) isCmdArgument_Value() {}

func (m *CmdArgument) GetValue() isCmdArgument_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CmdArgument) GetArg() string {
	if x, ok := m.GetValue().(*CmdArgument_Arg); ok {
		return x.Arg
	}
	return ""
}

func (m *CmdArgument) GetFileArg() *FileArgument {
	if x, ok := m.GetValue().(*CmdArgument_FileArg); ok {
		return x.FileArg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CmdArgument) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CmdArgument_OneofMarshaler, _CmdArgument_OneofUnmarshaler, _CmdArgument_OneofSizer, []interface{}{
		(*CmdArgument_Arg)(nil),
		(*CmdArgument_FileArg)(nil),
	}
}

func _CmdArgument_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CmdArgument)
	// Value
	switch x := m.Value.(type) {
	case *CmdArgument_Arg:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Arg)
	case *CmdArgument_FileArg:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileArg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CmdArgument.Value has unexpected type %T", x)
	}
	return nil
}

func _CmdArgument_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CmdArgument)
	switch tag {
	case 1: // Value.arg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &CmdArgument_Arg{x}
		return true, err
	case 2: // Value.file_arg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileArgument)
		err := b.DecodeMessage(msg)
		m.Value = &CmdArgument_FileArg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CmdArgument_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CmdArgument)
	// Value
	switch x := m.Value.(type) {
	case *CmdArgument_Arg:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Arg)))
		n += len(x.Arg)
	case *CmdArgument_FileArg:
		s := proto.Size(x.FileArg)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// FileArgument
// Represents a file that is part of the command line execution. The location of the file may be embedded
// into the command line, or be treated as a fixed or silent argument.
type FileArgument struct {
	Id               *string                   `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Input            *bool                     `protobuf:"varint,2,req,name=input" json:"input,omitempty"`
	Type             *FileArgument_FileArgType `protobuf:"varint,3,req,name=type,enum=agro_pb.FileArgument_FileArgType" json:"type,omitempty"`
	Name             *string                   `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	NameKey          *string                   `protobuf:"bytes,5,opt,name=name_key" json:"name_key,omitempty"`
	Silent           *bool                     `protobuf:"varint,6,opt,name=silent" json:"silent,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *FileArgument) Reset()                    { *m = FileArgument{} }
func (m *FileArgument) String() string            { return proto.CompactTextString(m) }
func (*FileArgument) ProtoMessage()               {}
func (*FileArgument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FileArgument) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *FileArgument) GetInput() bool {
	if m != nil && m.Input != nil {
		return *m.Input
	}
	return false
}

func (m *FileArgument) GetType() FileArgument_FileArgType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return FileArgument_PATH
}

func (m *FileArgument) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FileArgument) GetNameKey() string {
	if m != nil && m.NameKey != nil {
		return *m.NameKey
	}
	return ""
}

func (m *FileArgument) GetSilent() bool {
	if m != nil && m.Silent != nil {
		return *m.Silent
	}
	return false
}

// *
// Worker Info
type WorkerInfo struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	LastPing         *int64   `protobuf:"varint,2,req,name=last_ping" json:"last_ping,omitempty"`
	Hostname         *string  `protobuf:"bytes,3,req,name=hostname" json:"hostname,omitempty"`
	Tags             []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *WorkerInfo) Reset()                    { *m = WorkerInfo{} }
func (m *WorkerInfo) String() string            { return proto.CompactTextString(m) }
func (*WorkerInfo) ProtoMessage()               {}
func (*WorkerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *WorkerInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *WorkerInfo) GetLastPing() int64 {
	if m != nil && m.LastPing != nil {
		return *m.LastPing
	}
	return 0
}

func (m *WorkerInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *WorkerInfo) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// *
// An array of tags to search for tasks
type TagArray struct {
	Tags             []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TagArray) Reset()                    { *m = TagArray{} }
func (m *TagArray) String() string            { return proto.CompactTextString(m) }
func (*TagArray) ProtoMessage()               {}
func (*TagArray) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *TagArray) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// *
// An array of ids to retrieve information about
type IDQuery struct {
	Ids              []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *IDQuery) Reset()                    { *m = IDQuery{} }
func (m *IDQuery) String() string            { return proto.CompactTextString(m) }
func (*IDQuery) ProtoMessage()               {}
func (*IDQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *IDQuery) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

type UpdateStateRequest struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	State            *State  `protobuf:"varint,2,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	WorkerId         *string `protobuf:"bytes,3,opt,name=worker_id" json:"worker_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UpdateStateRequest) Reset()                    { *m = UpdateStateRequest{} }
func (m *UpdateStateRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateStateRequest) ProtoMessage()               {}
func (*UpdateStateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UpdateStateRequest) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *UpdateStateRequest) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

func (m *UpdateStateRequest) GetWorkerId() string {
	if m != nil && m.WorkerId != nil {
		return *m.WorkerId
	}
	return ""
}

type JobLog struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Stdout           []byte  `protobuf:"bytes,2,req,name=stdout" json:"stdout,omitempty"`
	Stderr           []byte  `protobuf:"bytes,3,req,name=stderr" json:"stderr,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *JobLog) Reset()                    { *m = JobLog{} }
func (m *JobLog) String() string            { return proto.CompactTextString(m) }
func (*JobLog) ProtoMessage()               {}
func (*JobLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *JobLog) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *JobLog) GetStdout() []byte {
	if m != nil {
		return m.Stdout
	}
	return nil
}

func (m *JobLog) GetStderr() []byte {
	if m != nil {
		return m.Stderr
	}
	return nil
}

type JobRequest struct {
	Worker           *WorkerInfo `protobuf:"bytes,1,req,name=worker" json:"worker,omitempty"`
	Max              *int32      `protobuf:"varint,2,req,name=max" json:"max,omitempty"`
	Tags             []string    `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *JobRequest) Reset()                    { *m = JobRequest{} }
func (m *JobRequest) String() string            { return proto.CompactTextString(m) }
func (*JobRequest) ProtoMessage()               {}
func (*JobRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *JobRequest) GetWorker() *WorkerInfo {
	if m != nil {
		return m.Worker
	}
	return nil
}

func (m *JobRequest) GetMax() int32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *JobRequest) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// *
// A block of data from a file
type DataBlock struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Start            *int64  `protobuf:"varint,2,req,name=start" json:"start,omitempty"`
	Len              *int64  `protobuf:"varint,3,req,name=len" json:"len,omitempty"`
	Data             []byte  `protobuf:"bytes,4,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DataBlock) Reset()                    { *m = DataBlock{} }
func (m *DataBlock) String() string            { return proto.CompactTextString(m) }
func (*DataBlock) ProtoMessage()               {}
func (*DataBlock) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *DataBlock) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *DataBlock) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *DataBlock) GetLen() int64 {
	if m != nil && m.Len != nil {
		return *m.Len
	}
	return 0
}

func (m *DataBlock) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Basic meta-data about a file
type FileInfo struct {
	Name             *string  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Id               *string  `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	Size             *int64   `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Urls             []string `protobuf:"bytes,4,rep,name=urls" json:"urls,omitempty"`
	State            *State   `protobuf:"varint,5,opt,name=state,enum=agro_pb.State" json:"state,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *FileInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FileInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *FileInfo) GetSize() int64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *FileInfo) GetUrls() []string {
	if m != nil {
		return m.Urls
	}
	return nil
}

func (m *FileInfo) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

type Field struct {
	Path []string `protobuf:"bytes,1,rep,name=path" json:"path,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Field_StrValue
	//	*Field_IntValue
	//	*Field_FloatValue
	//	*Field_BoolValue
	//	*Field_ListDeclare
	//	*Field_MapDeclare
	Value            isField_Value `protobuf_oneof:"Value"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Field) Reset()                    { *m = Field{} }
func (m *Field) String() string            { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()               {}
func (*Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isField_Value interface {
	isField_Value()
}

type Field_StrValue struct {
	StrValue string `protobuf:"bytes,2,opt,name=str_value,oneof"`
}
type Field_IntValue struct {
	IntValue int64 `protobuf:"varint,3,opt,name=int_value,oneof"`
}
type Field_FloatValue struct {
	FloatValue float64 `protobuf:"fixed64,4,opt,name=float_value,oneof"`
}
type Field_BoolValue struct {
	BoolValue bool `protobuf:"varint,5,opt,name=bool_value,oneof"`
}
type Field_ListDeclare struct {
	ListDeclare int64 `protobuf:"varint,6,opt,name=list_declare,oneof"`
}
type Field_MapDeclare struct {
	MapDeclare int64 `protobuf:"varint,7,opt,name=map_declare,oneof"`
}

func (*Field_StrValue) isField_Value()    {}
func (*Field_IntValue) isField_Value()    {}
func (*Field_FloatValue) isField_Value()  {}
func (*Field_BoolValue) isField_Value()   {}
func (*Field_ListDeclare) isField_Value() {}
func (*Field_MapDeclare) isField_Value()  {}

func (m *Field) GetValue() isField_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Field) GetPath() []string {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Field) GetStrValue() string {
	if x, ok := m.GetValue().(*Field_StrValue); ok {
		return x.StrValue
	}
	return ""
}

func (m *Field) GetIntValue() int64 {
	if x, ok := m.GetValue().(*Field_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (m *Field) GetFloatValue() float64 {
	if x, ok := m.GetValue().(*Field_FloatValue); ok {
		return x.FloatValue
	}
	return 0
}

func (m *Field) GetBoolValue() bool {
	if x, ok := m.GetValue().(*Field_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *Field) GetListDeclare() int64 {
	if x, ok := m.GetValue().(*Field_ListDeclare); ok {
		return x.ListDeclare
	}
	return 0
}

func (m *Field) GetMapDeclare() int64 {
	if x, ok := m.GetValue().(*Field_MapDeclare); ok {
		return x.MapDeclare
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Field) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Field_OneofMarshaler, _Field_OneofUnmarshaler, _Field_OneofSizer, []interface{}{
		(*Field_StrValue)(nil),
		(*Field_IntValue)(nil),
		(*Field_FloatValue)(nil),
		(*Field_BoolValue)(nil),
		(*Field_ListDeclare)(nil),
		(*Field_MapDeclare)(nil),
	}
}

func _Field_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Field)
	// Value
	switch x := m.Value.(type) {
	case *Field_StrValue:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StrValue)
	case *Field_IntValue:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IntValue))
	case *Field_FloatValue:
		b.EncodeVarint(4<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.FloatValue))
	case *Field_BoolValue:
		t := uint64(0)
		if x.BoolValue {
			t = 1
		}
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Field_ListDeclare:
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ListDeclare))
	case *Field_MapDeclare:
		b.EncodeVarint(7<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.MapDeclare))
	case nil:
	default:
		return fmt.Errorf("Field.Value has unexpected type %T", x)
	}
	return nil
}

func _Field_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Field)
	switch tag {
	case 2: // Value.str_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Field_StrValue{x}
		return true, err
	case 3: // Value.int_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Field_IntValue{int64(x)}
		return true, err
	case 4: // Value.float_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Field_FloatValue{math.Float64frombits(x)}
		return true, err
	case 5: // Value.bool_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Field_BoolValue{x != 0}
		return true, err
	case 6: // Value.list_declare
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Field_ListDeclare{int64(x)}
		return true, err
	case 7: // Value.map_declare
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Field_MapDeclare{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Field_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Field)
	// Value
	switch x := m.Value.(type) {
	case *Field_StrValue:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StrValue)))
		n += len(x.StrValue)
	case *Field_IntValue:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IntValue))
	case *Field_FloatValue:
		n += proto.SizeVarint(4<<3 | proto.WireFixed64)
		n += 8
	case *Field_BoolValue:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *Field_ListDeclare:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ListDeclare))
	case *Field_MapDeclare:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.MapDeclare))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Document struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Fields           []*Field `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Document) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Document) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// Identify a file for operations
type FileID struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FileID) Reset()                    { *m = FileID{} }
func (m *FileID) String() string            { return proto.CompactTextString(m) }
func (*FileID) ProtoMessage()               {}
func (*FileID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *FileID) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

// *
// The State of a file.
// Possible states:
//  - RUNNING : The file has been created, but is not ready to be read (still uploading)
//  - OK : The file is ready for use
//  - ERROR :  File data is damaged
type FileState struct {
	State            *State `protobuf:"varint,1,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FileState) Reset()                    { *m = FileState{} }
func (m *FileState) String() string            { return proto.CompactTextString(m) }
func (*FileState) ProtoMessage()               {}
func (*FileState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *FileState) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

// *
// Request to get part of a file to read
type ReadRequest struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Start            *int64  `protobuf:"varint,2,req,name=start" json:"start,omitempty"`
	Size             *int64  `protobuf:"varint,3,req,name=size" json:"size,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ReadRequest) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ReadRequest) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *ReadRequest) GetSize() int64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func init() {
	proto.RegisterType((*Task)(nil), "agro_pb.Task")
	proto.RegisterType((*Job)(nil), "agro_pb.Job")
	proto.RegisterType((*JobStatus)(nil), "agro_pb.JobStatus")
	proto.RegisterType((*TaskStatus)(nil), "agro_pb.TaskStatus")
	proto.RegisterType((*TaskRequirement)(nil), "agro_pb.TaskRequirement")
	proto.RegisterType((*CmdArgument)(nil), "agro_pb.CmdArgument")
	proto.RegisterType((*FileArgument)(nil), "agro_pb.FileArgument")
	proto.RegisterType((*WorkerInfo)(nil), "agro_pb.WorkerInfo")
	proto.RegisterType((*TagArray)(nil), "agro_pb.TagArray")
	proto.RegisterType((*IDQuery)(nil), "agro_pb.IDQuery")
	proto.RegisterType((*UpdateStateRequest)(nil), "agro_pb.UpdateStateRequest")
	proto.RegisterType((*JobLog)(nil), "agro_pb.JobLog")
	proto.RegisterType((*JobRequest)(nil), "agro_pb.JobRequest")
	proto.RegisterType((*DataBlock)(nil), "agro_pb.DataBlock")
	proto.RegisterType((*FileInfo)(nil), "agro_pb.FileInfo")
	proto.RegisterType((*Field)(nil), "agro_pb.Field")
	proto.RegisterType((*Document)(nil), "agro_pb.Document")
	proto.RegisterType((*FileID)(nil), "agro_pb.FileID")
	proto.RegisterType((*FileState)(nil), "agro_pb.FileState")
	proto.RegisterType((*ReadRequest)(nil), "agro_pb.ReadRequest")
	proto.RegisterEnum("agro_pb.State", State_name, State_value)
	proto.RegisterEnum("agro_pb.FileArgument_FileArgType", FileArgument_FileArgType_name, FileArgument_FileArgType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Scheduler service

type SchedulerClient interface {
	GetJobToRun(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (Scheduler_GetJobToRunClient, error)
	GetJob(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (*Job, error)
	SetJobLogs(ctx context.Context, in *JobLog, opts ...grpc.CallOption) (*JobStatus, error)
	SearchTasks(ctx context.Context, in *TagArray, opts ...grpc.CallOption) (Scheduler_SearchTasksClient, error)
	AddTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*TaskStatus, error)
	GetTask(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (*Task, error)
	GetTaskStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetTaskStatusClient, error)
	GetJobStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetJobStatusClient, error)
	UpdateJobState(ctx context.Context, in *UpdateStateRequest, opts ...grpc.CallOption) (*JobStatus, error)
	WorkerPing(ctx context.Context, in *WorkerInfo, opts ...grpc.CallOption) (*WorkerInfo, error)
	SearchWorkers(ctx context.Context, in *TagArray, opts ...grpc.CallOption) (Scheduler_SearchWorkersClient, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) GetJobToRun(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (Scheduler_GetJobToRunClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[0], c.cc, "/agro_pb.Scheduler/GetJobToRun", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerGetJobToRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_GetJobToRunClient interface {
	Recv() (*Job, error)
	grpc.ClientStream
}

type schedulerGetJobToRunClient struct {
	grpc.ClientStream
}

func (x *schedulerGetJobToRunClient) Recv() (*Job, error) {
	m := new(Job)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) GetJob(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/GetJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) SetJobLogs(ctx context.Context, in *JobLog, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/SetJobLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) SearchTasks(ctx context.Context, in *TagArray, opts ...grpc.CallOption) (Scheduler_SearchTasksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[1], c.cc, "/agro_pb.Scheduler/SearchTasks", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerSearchTasksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_SearchTasksClient interface {
	Recv() (*Task, error)
	grpc.ClientStream
}

type schedulerSearchTasksClient struct {
	grpc.ClientStream
}

func (x *schedulerSearchTasksClient) Recv() (*Task, error) {
	m := new(Task)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) AddTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*TaskStatus, error) {
	out := new(TaskStatus)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/AddTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) GetTask(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (*Task, error) {
	out := new(Task)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/GetTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) GetTaskStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetTaskStatusClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[2], c.cc, "/agro_pb.Scheduler/GetTaskStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerGetTaskStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_GetTaskStatusClient interface {
	Recv() (*TaskStatus, error)
	grpc.ClientStream
}

type schedulerGetTaskStatusClient struct {
	grpc.ClientStream
}

func (x *schedulerGetTaskStatusClient) Recv() (*TaskStatus, error) {
	m := new(TaskStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) GetJobStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetJobStatusClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[3], c.cc, "/agro_pb.Scheduler/GetJobStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerGetJobStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_GetJobStatusClient interface {
	Recv() (*JobStatus, error)
	grpc.ClientStream
}

type schedulerGetJobStatusClient struct {
	grpc.ClientStream
}

func (x *schedulerGetJobStatusClient) Recv() (*JobStatus, error) {
	m := new(JobStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) UpdateJobState(ctx context.Context, in *UpdateStateRequest, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/UpdateJobState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) WorkerPing(ctx context.Context, in *WorkerInfo, opts ...grpc.CallOption) (*WorkerInfo, error) {
	out := new(WorkerInfo)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/WorkerPing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) SearchWorkers(ctx context.Context, in *TagArray, opts ...grpc.CallOption) (Scheduler_SearchWorkersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[4], c.cc, "/agro_pb.Scheduler/SearchWorkers", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerSearchWorkersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_SearchWorkersClient interface {
	Recv() (*WorkerInfo, error)
	grpc.ClientStream
}

type schedulerSearchWorkersClient struct {
	grpc.ClientStream
}

func (x *schedulerSearchWorkersClient) Recv() (*WorkerInfo, error) {
	m := new(WorkerInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Scheduler service

type SchedulerServer interface {
	GetJobToRun(*JobRequest, Scheduler_GetJobToRunServer) error
	GetJob(context.Context, *IDQuery) (*Job, error)
	SetJobLogs(context.Context, *JobLog) (*JobStatus, error)
	SearchTasks(*TagArray, Scheduler_SearchTasksServer) error
	AddTask(context.Context, *Task) (*TaskStatus, error)
	GetTask(context.Context, *IDQuery) (*Task, error)
	GetTaskStatus(*IDQuery, Scheduler_GetTaskStatusServer) error
	GetJobStatus(*IDQuery, Scheduler_GetJobStatusServer) error
	UpdateJobState(context.Context, *UpdateStateRequest) (*JobStatus, error)
	WorkerPing(context.Context, *WorkerInfo) (*WorkerInfo, error)
	SearchWorkers(*TagArray, Scheduler_SearchWorkersServer) error
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_GetJobToRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).GetJobToRun(m, &schedulerGetJobToRunServer{stream})
}

type Scheduler_GetJobToRunServer interface {
	Send(*Job) error
	grpc.ServerStream
}

type schedulerGetJobToRunServer struct {
	grpc.ServerStream
}

func (x *schedulerGetJobToRunServer) Send(m *Job) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(IDQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).GetJob(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_SetJobLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(JobLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).SetJobLogs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_SearchTasks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagArray)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).SearchTasks(m, &schedulerSearchTasksServer{stream})
}

type Scheduler_SearchTasksServer interface {
	Send(*Task) error
	grpc.ServerStream
}

type schedulerSearchTasksServer struct {
	grpc.ServerStream
}

func (x *schedulerSearchTasksServer) Send(m *Task) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_AddTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).AddTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(IDQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).GetTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_GetTaskStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IDQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).GetTaskStatus(m, &schedulerGetTaskStatusServer{stream})
}

type Scheduler_GetTaskStatusServer interface {
	Send(*TaskStatus) error
	grpc.ServerStream
}

type schedulerGetTaskStatusServer struct {
	grpc.ServerStream
}

func (x *schedulerGetTaskStatusServer) Send(m *TaskStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_GetJobStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IDQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).GetJobStatus(m, &schedulerGetJobStatusServer{stream})
}

type Scheduler_GetJobStatusServer interface {
	Send(*JobStatus) error
	grpc.ServerStream
}

type schedulerGetJobStatusServer struct {
	grpc.ServerStream
}

func (x *schedulerGetJobStatusServer) Send(m *JobStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_UpdateJobState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpdateStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).UpdateJobState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_WorkerPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WorkerInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).WorkerPing(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_SearchWorkers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagArray)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).SearchWorkers(m, &schedulerSearchWorkersServer{stream})
}

type Scheduler_SearchWorkersServer interface {
	Send(*WorkerInfo) error
	grpc.ServerStream
}

type schedulerSearchWorkersServer struct {
	grpc.ServerStream
}

func (x *schedulerSearchWorkersServer) Send(m *WorkerInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agro_pb.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJob",
			Handler:    _Scheduler_GetJob_Handler,
		},
		{
			MethodName: "SetJobLogs",
			Handler:    _Scheduler_SetJobLogs_Handler,
		},
		{
			MethodName: "AddTask",
			Handler:    _Scheduler_AddTask_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _Scheduler_GetTask_Handler,
		},
		{
			MethodName: "UpdateJobState",
			Handler:    _Scheduler_UpdateJobState_Handler,
		},
		{
			MethodName: "WorkerPing",
			Handler:    _Scheduler_WorkerPing_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetJobToRun",
			Handler:       _Scheduler_GetJobToRun_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTasks",
			Handler:       _Scheduler_SearchTasks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTaskStatus",
			Handler:       _Scheduler_GetTaskStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetJobStatus",
			Handler:       _Scheduler_GetJobStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchWorkers",
			Handler:       _Scheduler_SearchWorkers_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for FileStore service

type FileStoreClient interface {
	CreateDoc(ctx context.Context, in *Document, opts ...grpc.CallOption) (*FileState, error)
	GetDoc(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*Document, error)
	UpdateDoc(ctx context.Context, in *Document, opts ...grpc.CallOption) (*FileState, error)
	DeleteDoc(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error)
	CreateFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileState, error)
	WriteFile(ctx context.Context, in *DataBlock, opts ...grpc.CallOption) (*FileState, error)
	CommitFile(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error)
	GetFileInfo(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileInfo, error)
	ReadFile(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*DataBlock, error)
	DeleteFile(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error)
}

type fileStoreClient struct {
	cc *grpc.ClientConn
}

func NewFileStoreClient(cc *grpc.ClientConn) FileStoreClient {
	return &fileStoreClient{cc}
}

func (c *fileStoreClient) CreateDoc(ctx context.Context, in *Document, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/CreateDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) GetDoc(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*Document, error) {
	out := new(Document)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/GetDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) UpdateDoc(ctx context.Context, in *Document, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/UpdateDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) DeleteDoc(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/DeleteDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) CreateFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/CreateFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) WriteFile(ctx context.Context, in *DataBlock, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/WriteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) CommitFile(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/CommitFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) GetFileInfo(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/GetFileInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) ReadFile(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*DataBlock, error) {
	out := new(DataBlock)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/ReadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) DeleteFile(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/DeleteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileStore service

type FileStoreServer interface {
	CreateDoc(context.Context, *Document) (*FileState, error)
	GetDoc(context.Context, *FileID) (*Document, error)
	UpdateDoc(context.Context, *Document) (*FileState, error)
	DeleteDoc(context.Context, *FileID) (*FileState, error)
	CreateFile(context.Context, *FileInfo) (*FileState, error)
	WriteFile(context.Context, *DataBlock) (*FileState, error)
	CommitFile(context.Context, *FileID) (*FileState, error)
	GetFileInfo(context.Context, *FileID) (*FileInfo, error)
	ReadFile(context.Context, *ReadRequest) (*DataBlock, error)
	DeleteFile(context.Context, *FileID) (*FileState, error)
}

func RegisterFileStoreServer(s *grpc.Server, srv FileStoreServer) {
	s.RegisterService(&_FileStore_serviceDesc, srv)
}

func _FileStore_CreateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).CreateDoc(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_GetDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).GetDoc(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_UpdateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).UpdateDoc(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_DeleteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).DeleteDoc(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_CreateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).CreateFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).WriteFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_CommitFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).CommitFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_GetFileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).GetFileInfo(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).ReadFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).DeleteFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _FileStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agro_pb.FileStore",
	HandlerType: (*FileStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDoc",
			Handler:    _FileStore_CreateDoc_Handler,
		},
		{
			MethodName: "GetDoc",
			Handler:    _FileStore_GetDoc_Handler,
		},
		{
			MethodName: "UpdateDoc",
			Handler:    _FileStore_UpdateDoc_Handler,
		},
		{
			MethodName: "DeleteDoc",
			Handler:    _FileStore_DeleteDoc_Handler,
		},
		{
			MethodName: "CreateFile",
			Handler:    _FileStore_CreateFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FileStore_WriteFile_Handler,
		},
		{
			MethodName: "CommitFile",
			Handler:    _FileStore_CommitFile_Handler,
		},
		{
			MethodName: "GetFileInfo",
			Handler:    _FileStore_GetFileInfo_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FileStore_ReadFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _FileStore_DeleteFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 1224 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0x5d, 0x6f, 0xe3, 0x44,
	0x17, 0xae, 0xf3, 0xed, 0x93, 0xa4, 0xcd, 0x4e, 0xdb, 0x55, 0x94, 0x57, 0x2f, 0x2a, 0xe6, 0x66,
	0xa9, 0x50, 0xba, 0xca, 0x2e, 0xd5, 0x0a, 0xae, 0xb2, 0x4d, 0xb6, 0x0d, 0xbb, 0xb4, 0xdd, 0x7c,
	0x50, 0x90, 0x90, 0xa2, 0x69, 0x3c, 0x4d, 0x4d, 0x1d, 0x3b, 0x8c, 0x27, 0x40, 0xf9, 0x35, 0x5c,
	0xf0, 0xb3, 0xb8, 0xe0, 0x12, 0xfe, 0x05, 0x67, 0x66, 0x6c, 0xc7, 0x49, 0x5c, 0xb4, 0x95, 0xb8,
	0xf3, 0x9c, 0x39, 0x5f, 0xcf, 0x39, 0xe7, 0x39, 0x63, 0xa8, 0xcd, 0xb9, 0x2f, 0xfc, 0x23, 0x3a,
	0xe5, 0x7e, 0x53, 0x7d, 0x92, 0xa2, 0xfc, 0x1e, 0xcf, 0xaf, 0xad, 0x3f, 0x0d, 0xc8, 0x0d, 0x69,
	0x70, 0x47, 0x00, 0x32, 0x8e, 0x5d, 0x37, 0x0e, 0x32, 0xcf, 0x4c, 0xb2, 0x07, 0x15, 0x81, 0xb2,
	0xb1, 0xcd, 0xe6, 0xcc, 0xb3, 0x83, 0x7a, 0xe6, 0x20, 0x8b, 0xd2, 0x1d, 0x28, 0x4e, 0xfc, 0xd9,
	0x8c, 0x7a, 0x76, 0x3d, 0xab, 0xd4, 0x2c, 0xc8, 0x51, 0x3e, 0x0d, 0xea, 0x39, 0xbc, 0x2e, 0xb7,
	0xf6, 0x9a, 0xa1, 0xcf, 0xe6, 0xc9, 0xcc, 0x6e, 0xf3, 0xe9, 0x62, 0xc6, 0x3c, 0x41, 0x9e, 0x80,
	0x39, 0xf1, 0x3d, 0x41, 0x1d, 0x8f, 0xf1, 0x7a, 0xfe, 0xc0, 0x40, 0xb3, 0x0a, 0xe4, 0x04, 0x45,
	0xb3, 0x82, 0xf2, 0xda, 0x84, 0x0a, 0x67, 0x3f, 0x2e, 0x1c, 0xce, 0xa4, 0x7e, 0x50, 0x2f, 0x2a,
	0x67, 0xf5, 0xd8, 0x99, 0x4c, 0xae, 0xbf, 0x54, 0x20, 0xff, 0x87, 0x7c, 0x20, 0xa8, 0x60, 0xf5,
	0x12, 0x3a, 0xdb, 0x6e, 0x6d, 0xc7, 0x8a, 0x03, 0x29, 0x95, 0xf1, 0x66, 0xf4, 0x97, 0x31, 0x67,
	0x82, 0xdf, 0xd7, 0x4d, 0x54, 0xc9, 0x5b, 0x7f, 0x1b, 0x90, 0xfd, 0xca, 0xbf, 0x5e, 0x41, 0x88,
	0x58, 0x14, 0x42, 0x14, 0x64, 0x22, 0xc1, 0x7f, 0x02, 0x6e, 0x1d, 0x4e, 0xe1, 0x43, 0xe1, 0x14,
	0x31, 0xea, 0x26, 0x9c, 0x6d, 0x28, 0x04, 0xc2, 0xf6, 0x17, 0x42, 0xc1, 0x35, 0xc3, 0x33, 0xe3,
	0x5c, 0x61, 0x53, 0xe7, 0x9f, 0x7d, 0x7e, 0x87, 0xe1, 0x41, 0x9e, 0xad, 0x63, 0x30, 0x11, 0xaa,
	0xb4, 0x5d, 0x04, 0x2b, 0x80, 0xe3, 0x38, 0x99, 0xb4, 0x38, 0xd6, 0xf7, 0x00, 0x32, 0xb3, 0x47,
	0x1b, 0x92, 0x7d, 0xa8, 0x62, 0xdd, 0xe6, 0x2e, 0x13, 0xcc, 0x1e, 0xff, 0xe0, 0x5f, 0x63, 0xf5,
	0xc2, 0x1e, 0xf3, 0x85, 0xa7, 0xab, 0x67, 0x5a, 0x4d, 0xd8, 0x59, 0xc7, 0x8d, 0x0a, 0x1e, 0x9d,
	0xb1, 0x30, 0x48, 0x15, 0xf2, 0x3f, 0x51, 0x77, 0xa1, 0x83, 0x98, 0xd6, 0x25, 0x94, 0x93, 0x65,
	0xae, 0x42, 0x16, 0x5b, 0x81, 0xaa, 0xe8, 0xf9, 0x6c, 0x8b, 0x7c, 0x0a, 0xa5, 0x1b, 0xc7, 0x65,
	0x63, 0x29, 0xcb, 0xa0, 0xac, 0xdc, 0xda, 0x8f, 0x93, 0x7a, 0x83, 0x17, 0x91, 0xdd, 0xd9, 0xd6,
	0xeb, 0x22, 0xe4, 0xbf, 0x91, 0x7e, 0xad, 0x3f, 0x0c, 0xa8, 0x24, 0xef, 0x56, 0x20, 0x62, 0x74,
	0xc7, 0x9b, 0x63, 0x8d, 0x65, 0xf4, 0x12, 0x39, 0xc2, 0xf9, 0xbc, 0x9f, 0x33, 0x35, 0x07, 0xdb,
	0xad, 0x8f, 0x53, 0x7d, 0x47, 0x87, 0x21, 0x2a, 0xc6, 0x58, 0x72, 0x0a, 0x7a, 0x0d, 0x4a, 0xf2,
	0x34, 0xbe, 0x63, 0xf7, 0xe1, 0x4c, 0xc8, 0xa6, 0xa1, 0xba, 0x27, 0x70, 0x1a, 0x8c, 0x67, 0x25,
	0x09, 0x2f, 0x69, 0x5e, 0x82, 0xdc, 0x65, 0x7b, 0x78, 0x56, 0x33, 0x88, 0x09, 0xf9, 0xf3, 0xf6,
	0xd7, 0xdd, 0x4e, 0x2d, 0x23, 0x3f, 0xfb, 0xdd, 0xd3, 0xee, 0xb7, 0xb5, 0x2c, 0xa6, 0x5a, 0x18,
	0x0c, 0x3b, 0x17, 0xa3, 0x61, 0x2d, 0x17, 0x7e, 0x77, 0xfb, 0xfd, 0x5a, 0x5e, 0xaa, 0xe0, 0x77,
	0xef, 0xbc, 0x56, 0xb0, 0xde, 0x02, 0x5c, 0xa9, 0x31, 0xe8, 0x79, 0x37, 0xfe, 0x0a, 0x36, 0x1c,
	0x51, 0x97, 0x06, 0x62, 0x3c, 0x77, 0xbc, 0xa9, 0xc2, 0x97, 0x95, 0x09, 0xde, 0xfa, 0x81, 0x50,
	0x29, 0xeb, 0x59, 0x8f, 0x18, 0xa9, 0xbb, 0x55, 0x87, 0xd2, 0x90, 0x4e, 0xdb, 0x9c, 0xd3, 0xfb,
	0xf8, 0xc6, 0x50, 0x37, 0x4f, 0xa1, 0xd8, 0xeb, 0xbc, 0x5f, 0x30, 0x7e, 0x4f, 0xca, 0x90, 0x75,
	0xec, 0x48, 0xde, 0x07, 0x32, 0x9a, 0xdb, 0x38, 0x0e, 0x6a, 0x26, 0x64, 0x9b, 0x59, 0x20, 0x1e,
	0x33, 0x45, 0x98, 0xa5, 0x1e, 0x63, 0x49, 0x48, 0x35, 0x41, 0xd6, 0x4b, 0x28, 0xe0, 0x24, 0xbf,
	0xf3, 0xa7, 0x2b, 0x7e, 0x96, 0x7c, 0x90, 0x8e, 0x2a, 0x09, 0x3e, 0x48, 0x24, 0x15, 0xeb, 0x1d,
	0x00, 0x5a, 0x45, 0x19, 0x7c, 0x12, 0xb3, 0x43, 0x5a, 0x97, 0x5b, 0xbb, 0x71, 0xd8, 0x44, 0xb5,
	0x10, 0x09, 0x6e, 0x0c, 0xe5, 0x2f, 0x1f, 0xe3, 0xcd, 0x2a, 0x5c, 0x6d, 0x30, 0x3b, 0x54, 0xd0,
	0xd7, 0xae, 0x3f, 0xb9, 0x5b, 0x9f, 0x18, 0x84, 0xc3, 0x45, 0x58, 0x51, 0x74, 0x81, 0xed, 0x55,
	0x29, 0x64, 0xa5, 0x0b, 0x2c, 0x05, 0xc5, 0x62, 0xca, 0x84, 0xc6, 0x50, 0x92, 0xbd, 0x56, 0x91,
	0x56, 0x67, 0x5e, 0xfb, 0xcb, 0x44, 0x0d, 0x08, 0x9c, 0x5f, 0x99, 0x82, 0xae, 0x3c, 0x2c, 0xb8,
	0x1b, 0xb6, 0x63, 0x59, 0xba, 0x7c, 0xda, 0xc2, 0xb3, 0x7e, 0x37, 0x20, 0xff, 0xc6, 0x61, 0xae,
	0x2d, 0xcd, 0xe6, 0x54, 0xdc, 0xea, 0x9e, 0x90, 0x5d, 0x30, 0x03, 0xc1, 0xc7, 0x11, 0xad, 0x34,
	0x75, 0x50, 0xe8, 0x78, 0x22, 0x14, 0xaa, 0x60, 0x28, 0xdc, 0x87, 0xf2, 0x8d, 0xeb, 0xd3, 0x48,
	0x2c, 0xa7, 0xd8, 0x40, 0xf1, 0x1e, 0xc0, 0xb5, 0xef, 0xbb, 0xa1, 0x54, 0x06, 0x2f, 0xa1, 0xf4,
	0x29, 0x54, 0x5c, 0x07, 0xe7, 0xc9, 0x66, 0x13, 0x97, 0x72, 0xa6, 0x26, 0x3a, 0x74, 0x32, 0xa3,
	0xf3, 0x58, 0x5c, 0xd4, 0xe2, 0x25, 0x01, 0x8f, 0xa1, 0xd4, 0xf1, 0x27, 0x9b, 0xdc, 0xfb, 0x08,
	0x0a, 0x37, 0x32, 0x7b, 0xfd, 0xc8, 0x94, 0x13, 0xf0, 0x14, 0x28, 0x6b, 0x0f, 0x0a, 0xaa, 0x7e,
	0x9d, 0xa4, 0x95, 0x75, 0x08, 0xa6, 0x94, 0xea, 0xe1, 0x89, 0x0b, 0x64, 0xa4, 0xae, 0xb6, 0x63,
	0x28, 0xf7, 0x19, 0xb5, 0xd3, 0xa6, 0x72, 0xad, 0x8d, 0xcb, 0x2e, 0xe0, 0xe9, 0xf0, 0x0a, 0xe9,
	0xa5, 0xfc, 0x23, 0xcf, 0x90, 0x70, 0x17, 0xfd, 0xda, 0x16, 0x36, 0xba, 0x78, 0xd5, 0xee, 0x0d,
	0x7b, 0xe7, 0xa7, 0x9a, 0xad, 0xfd, 0x6e, 0xbb, 0xf3, 0x1d, 0xb2, 0x15, 0x69, 0x79, 0xd9, 0x1e,
	0x0d, 0x90, 0xb9, 0x8a, 0xae, 0xef, 0x47, 0xdd, 0x11, 0x7e, 0xe7, 0xa4, 0x7e, 0x7f, 0x74, 0x7e,
	0x2e, 0xf5, 0xf3, 0xa4, 0x00, 0x99, 0x8b, 0xb7, 0xb5, 0x42, 0xeb, 0xaf, 0x1c, 0x98, 0x83, 0xc9,
	0x2d, 0xb3, 0x17, 0x2e, 0xe3, 0xe4, 0x25, 0x94, 0x4f, 0x99, 0xc0, 0xa1, 0x1d, 0xfa, 0xfd, 0x85,
	0x47, 0x96, 0x23, 0xba, 0x9c, 0xe3, 0x46, 0x25, 0x29, 0xb4, 0xb6, 0x9e, 0x1b, 0xe4, 0x10, 0x0a,
	0xda, 0x8a, 0xd4, 0xe2, 0xbb, 0x90, 0x9a, 0xeb, 0xda, 0xe4, 0x05, 0xc0, 0x40, 0xe9, 0x22, 0x99,
	0x02, 0xb2, 0x93, 0xbc, 0x45, 0x49, 0x83, 0x24, 0x05, 0xfa, 0x01, 0x50, 0x46, 0xe5, 0x01, 0xa3,
	0x7c, 0x72, 0x2b, 0x17, 0x77, 0x40, 0x9e, 0x24, 0x1e, 0x30, 0xbd, 0x1a, 0x1a, 0xd5, 0x95, 0x37,
	0x4d, 0x65, 0x75, 0x04, 0xc5, 0xb6, 0x6d, 0xab, 0xdf, 0x89, 0xd5, 0xdb, 0xc6, 0xee, 0xca, 0x31,
	0x8e, 0xf2, 0x19, 0x14, 0x11, 0x86, 0x32, 0xd8, 0xc4, 0xb1, 0x1e, 0x80, 0x7c, 0x01, 0xd5, 0x50,
	0x3b, 0x7c, 0xa7, 0x36, 0x6d, 0xd2, 0xe3, 0x60, 0x6a, 0xaf, 0xa0, 0xa2, 0x0b, 0xf6, 0xa0, 0x69,
	0x6a, 0x1d, 0xd0, 0xf2, 0x04, 0xb6, 0xf5, 0x72, 0x0b, 0xc5, 0x8c, 0xfc, 0x2f, 0xd6, 0xdc, 0xdc,
	0x7a, 0x0f, 0x94, 0xf3, 0x55, 0xb4, 0xa0, 0x2f, 0x71, 0x0f, 0x93, 0xb4, 0x3d, 0xd4, 0x48, 0x13,
	0xa2, 0xe5, 0x97, 0x50, 0xd5, 0x8d, 0xd0, 0xd2, 0xd4, 0x56, 0xa4, 0x9b, 0x3e, 0x37, 0x5a, 0xbf,
	0xe5, 0x22, 0xa2, 0xf8, 0x9c, 0xe1, 0xa8, 0x99, 0x27, 0x9c, 0x61, 0xae, 0xc8, 0xc4, 0x84, 0x9b,
	0x88, 0x97, 0x89, 0xd4, 0x63, 0x72, 0x61, 0x02, 0x4d, 0x35, 0x6a, 0xd2, 0x64, 0x67, 0xe5, 0xbe,
	0xd7, 0x69, 0x6c, 0xfa, 0x40, 0x7d, 0x8c, 0xa2, 0xcb, 0xf2, 0xa8, 0x28, 0x2d, 0x5c, 0xb5, 0x4c,
	0xfe, 0x45, 0xa4, 0x06, 0x4a, 0xb7, 0xf9, 0x1c, 0x40, 0xe3, 0x91, 0xc2, 0x44, 0xa8, 0x68, 0xe1,
	0x3e, 0x68, 0x66, 0x5e, 0x71, 0x27, 0xb4, 0x5a, 0xaa, 0xc4, 0x9b, 0xfe, 0x01, 0x33, 0xa4, 0xd1,
	0x09, 0xfe, 0x21, 0x3a, 0x42, 0xd9, 0x7d, 0x60, 0x8a, 0x2f, 0x14, 0xbb, 0xe3, 0x17, 0xe0, 0x5f,
	0x2a, 0x18, 0xe9, 0xa0, 0x11, 0xee, 0x4a, 0xb9, 0xb1, 0x54, 0x9c, 0xe5, 0x8f, 0x67, 0x62, 0x89,
	0x35, 0x52, 0xb2, 0xd6, 0x19, 0xea, 0x1a, 0x3e, 0x22, 0xc3, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0xe1, 0x34, 0xb5, 0x51, 0x1c, 0x0c, 0x00, 0x00,
}

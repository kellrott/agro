// Code generated by protoc-gen-go.
// source: proto/agro.proto
// DO NOT EDIT!

/*
Package agro_pb is a generated protocol buffer package.

It is generated from these files:
	proto/agro.proto

It has these top-level messages:
	Task
	Job
	JobStatus
	TaskStatus
	CmdArgument
	FileArgument
	TagArray
	IDQuery
	DataBlock
	FileInfo
	FileID
	FileState
	ReadRequest
*/
package agro_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// *
// The different states a job or a task can be in
type State int32

const (
	State_ERROR   State = 0
	State_WAITING State = 1
	State_QUEUED  State = 2
	State_PAUSED  State = 3
	State_RUNNING State = 4
	State_OK      State = 5
)

var State_name = map[int32]string{
	0: "ERROR",
	1: "WAITING",
	2: "QUEUED",
	3: "PAUSED",
	4: "RUNNING",
	5: "OK",
}
var State_value = map[string]int32{
	"ERROR":   0,
	"WAITING": 1,
	"QUEUED":  2,
	"PAUSED":  3,
	"RUNNING": 4,
	"OK":      5,
}

func (x State) Enum() *State {
	p := new(State)
	*p = x
	return p
}
func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (x *State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(State_value, data, "State")
	if err != nil {
		return err
	}
	*x = State(value)
	return nil
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type FileArgument_FileArgType int32

const (
	FileArgument_PATH   FileArgument_FileArgType = 1
	FileArgument_NAMED  FileArgument_FileArgType = 2
	FileArgument_REGEX  FileArgument_FileArgType = 3
	FileArgument_STDOUT FileArgument_FileArgType = 4
	FileArgument_STDERR FileArgument_FileArgType = 5
	FileArgument_STDIN  FileArgument_FileArgType = 6
)

var FileArgument_FileArgType_name = map[int32]string{
	1: "PATH",
	2: "NAMED",
	3: "REGEX",
	4: "STDOUT",
	5: "STDERR",
	6: "STDIN",
}
var FileArgument_FileArgType_value = map[string]int32{
	"PATH":   1,
	"NAMED":  2,
	"REGEX":  3,
	"STDOUT": 4,
	"STDERR": 5,
	"STDIN":  6,
}

func (x FileArgument_FileArgType) Enum() *FileArgument_FileArgType {
	p := new(FileArgument_FileArgType)
	*p = x
	return p
}
func (x FileArgument_FileArgType) String() string {
	return proto.EnumName(FileArgument_FileArgType_name, int32(x))
}
func (x *FileArgument_FileArgType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FileArgument_FileArgType_value, data, "FileArgument_FileArgType")
	if err != nil {
		return err
	}
	*x = FileArgument_FileArgType(value)
	return nil
}
func (FileArgument_FileArgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// *
// The Task Record
// A task is a request for work to be done, it does not represent a specific
// invocation of that work. It is abstract, and describes the request and its
// dependencies. A Job represents a real instance of a Task, and there may be
// multiple jobs for associated with a single task.
type Task struct {
	Id               *string        `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	TaskDepends      []string       `protobuf:"bytes,2,rep,name=task_depends" json:"task_depends,omitempty"`
	Command          *string        `protobuf:"bytes,3,req,name=command" json:"command,omitempty"`
	Args             []*CmdArgument `protobuf:"bytes,4,rep,name=args" json:"args,omitempty"`
	Container        *string        `protobuf:"bytes,5,opt,name=container" json:"container,omitempty"`
	Tags             []string       `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	State            *State         `protobuf:"varint,7,opt,name=state,enum=agro_pb.State" json:"state,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Task) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Task) GetTaskDepends() []string {
	if m != nil {
		return m.TaskDepends
	}
	return nil
}

func (m *Task) GetCommand() string {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return ""
}

func (m *Task) GetArgs() []*CmdArgument {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Task) GetContainer() string {
	if m != nil && m.Container != nil {
		return *m.Container
	}
	return ""
}

func (m *Task) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Task) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

// *
// The Job Record
// A job is a specific instance of a Task, representing a real invocation the will
// be or has been run on the system.
type Job struct {
	Id               *string        `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	TaskId           *string        `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	Command          *string        `protobuf:"bytes,3,req,name=command" json:"command,omitempty"`
	Args             []*CmdArgument `protobuf:"bytes,4,rep,name=args" json:"args,omitempty"`
	Container        *string        `protobuf:"bytes,5,opt,name=container" json:"container,omitempty"`
	State            *State         `protobuf:"varint,6,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	Stdout           *string        `protobuf:"bytes,7,req,name=stdout" json:"stdout,omitempty"`
	Stderr           *string        `protobuf:"bytes,8,req,name=stderr" json:"stderr,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Job) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Job) GetTaskId() string {
	if m != nil && m.TaskId != nil {
		return *m.TaskId
	}
	return ""
}

func (m *Job) GetCommand() string {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return ""
}

func (m *Job) GetArgs() []*CmdArgument {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Job) GetContainer() string {
	if m != nil && m.Container != nil {
		return *m.Container
	}
	return ""
}

func (m *Job) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

func (m *Job) GetStdout() string {
	if m != nil && m.Stdout != nil {
		return *m.Stdout
	}
	return ""
}

func (m *Job) GetStderr() string {
	if m != nil && m.Stderr != nil {
		return *m.Stderr
	}
	return ""
}

// *
// Job Status information
type JobStatus struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	State            *State  `protobuf:"varint,2,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *JobStatus) Reset()                    { *m = JobStatus{} }
func (m *JobStatus) String() string            { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()               {}
func (*JobStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *JobStatus) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *JobStatus) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

// *
// Task status
type TaskStatus struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	State            *State   `protobuf:"varint,2,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	CompletedJob     *string  `protobuf:"bytes,3,opt,name=completed_job" json:"completed_job,omitempty"`
	Runs             []string `protobuf:"bytes,4,rep,name=runs" json:"runs,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TaskStatus) Reset()                    { *m = TaskStatus{} }
func (m *TaskStatus) String() string            { return proto.CompactTextString(m) }
func (*TaskStatus) ProtoMessage()               {}
func (*TaskStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TaskStatus) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *TaskStatus) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

func (m *TaskStatus) GetCompletedJob() string {
	if m != nil && m.CompletedJob != nil {
		return *m.CompletedJob
	}
	return ""
}

func (m *TaskStatus) GetRuns() []string {
	if m != nil {
		return m.Runs
	}
	return nil
}

// *
// CmdArgument
// The arguments to be passed into the running program are passed in as an array of
// strings or file arguments
type CmdArgument struct {
	// Types that are valid to be assigned to Value:
	//	*CmdArgument_Arg
	//	*CmdArgument_FileArg
	Value            isCmdArgument_Value `protobuf_oneof:"Value"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *CmdArgument) Reset()                    { *m = CmdArgument{} }
func (m *CmdArgument) String() string            { return proto.CompactTextString(m) }
func (*CmdArgument) ProtoMessage()               {}
func (*CmdArgument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isCmdArgument_Value interface {
	isCmdArgument_Value()
}

type CmdArgument_Arg struct {
	Arg string `protobuf:"bytes,1,opt,name=arg,oneof"`
}
type CmdArgument_FileArg struct {
	FileArg *FileArgument `protobuf:"bytes,2,opt,name=file_arg,oneof"`
}

func (*CmdArgument_Arg) isCmdArgument_Value()     {}
func (*CmdArgument_FileArg) isCmdArgument_Value() {}

func (m *CmdArgument) GetValue() isCmdArgument_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CmdArgument) GetArg() string {
	if x, ok := m.GetValue().(*CmdArgument_Arg); ok {
		return x.Arg
	}
	return ""
}

func (m *CmdArgument) GetFileArg() *FileArgument {
	if x, ok := m.GetValue().(*CmdArgument_FileArg); ok {
		return x.FileArg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CmdArgument) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CmdArgument_OneofMarshaler, _CmdArgument_OneofUnmarshaler, _CmdArgument_OneofSizer, []interface{}{
		(*CmdArgument_Arg)(nil),
		(*CmdArgument_FileArg)(nil),
	}
}

func _CmdArgument_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CmdArgument)
	// Value
	switch x := m.Value.(type) {
	case *CmdArgument_Arg:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Arg)
	case *CmdArgument_FileArg:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileArg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CmdArgument.Value has unexpected type %T", x)
	}
	return nil
}

func _CmdArgument_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CmdArgument)
	switch tag {
	case 1: // Value.arg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &CmdArgument_Arg{x}
		return true, err
	case 2: // Value.file_arg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileArgument)
		err := b.DecodeMessage(msg)
		m.Value = &CmdArgument_FileArg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CmdArgument_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CmdArgument)
	// Value
	switch x := m.Value.(type) {
	case *CmdArgument_Arg:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Arg)))
		n += len(x.Arg)
	case *CmdArgument_FileArg:
		s := proto.Size(x.FileArg)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// FileArgument
// Represents a file that is part of the command line execution. The location of the file may be embedded
// into the command line, or be treated as a fixed or silent argument.
type FileArgument struct {
	Id               *string                   `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Input            *bool                     `protobuf:"varint,2,req,name=input" json:"input,omitempty"`
	Type             *FileArgument_FileArgType `protobuf:"varint,3,req,name=type,enum=agro_pb.FileArgument_FileArgType" json:"type,omitempty"`
	Name             *string                   `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	NameKey          *string                   `protobuf:"bytes,5,opt,name=name_key" json:"name_key,omitempty"`
	Silent           *bool                     `protobuf:"varint,6,opt,name=silent" json:"silent,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *FileArgument) Reset()                    { *m = FileArgument{} }
func (m *FileArgument) String() string            { return proto.CompactTextString(m) }
func (*FileArgument) ProtoMessage()               {}
func (*FileArgument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FileArgument) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *FileArgument) GetInput() bool {
	if m != nil && m.Input != nil {
		return *m.Input
	}
	return false
}

func (m *FileArgument) GetType() FileArgument_FileArgType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return FileArgument_PATH
}

func (m *FileArgument) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FileArgument) GetNameKey() string {
	if m != nil && m.NameKey != nil {
		return *m.NameKey
	}
	return ""
}

func (m *FileArgument) GetSilent() bool {
	if m != nil && m.Silent != nil {
		return *m.Silent
	}
	return false
}

// *
// An array of tags to search for tasks
type TagArray struct {
	Tags             []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TagArray) Reset()                    { *m = TagArray{} }
func (m *TagArray) String() string            { return proto.CompactTextString(m) }
func (*TagArray) ProtoMessage()               {}
func (*TagArray) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TagArray) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// *
// An array of ids to retrieve information about
type IDQuery struct {
	Ids              []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *IDQuery) Reset()                    { *m = IDQuery{} }
func (m *IDQuery) String() string            { return proto.CompactTextString(m) }
func (*IDQuery) ProtoMessage()               {}
func (*IDQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *IDQuery) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

// *
// A block of data from a file
type DataBlock struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Start            *int64  `protobuf:"varint,2,req,name=start" json:"start,omitempty"`
	Len              *int64  `protobuf:"varint,3,req,name=len" json:"len,omitempty"`
	Data             []byte  `protobuf:"bytes,4,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DataBlock) Reset()                    { *m = DataBlock{} }
func (m *DataBlock) String() string            { return proto.CompactTextString(m) }
func (*DataBlock) ProtoMessage()               {}
func (*DataBlock) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DataBlock) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *DataBlock) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *DataBlock) GetLen() int64 {
	if m != nil && m.Len != nil {
		return *m.Len
	}
	return 0
}

func (m *DataBlock) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Basic meta-data about a file
type FileInfo struct {
	Name             *string  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Id               *string  `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	Size             *int64   `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Urls             []string `protobuf:"bytes,4,rep,name=urls" json:"urls,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FileInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FileInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *FileInfo) GetSize() int64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *FileInfo) GetUrls() []string {
	if m != nil {
		return m.Urls
	}
	return nil
}

// *
// Identify a file for operations
type FileID struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FileID) Reset()                    { *m = FileID{} }
func (m *FileID) String() string            { return proto.CompactTextString(m) }
func (*FileID) ProtoMessage()               {}
func (*FileID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *FileID) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

// *
// The State of a file.
// Possible states:
//  - RUNNING : The file has been created, but is not ready to be read (still uploading)
//  - OK : The file is ready for use
//  - ERROR :  File data is damaged
type FileState struct {
	State            *State `protobuf:"varint,1,req,name=state,enum=agro_pb.State" json:"state,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FileState) Reset()                    { *m = FileState{} }
func (m *FileState) String() string            { return proto.CompactTextString(m) }
func (*FileState) ProtoMessage()               {}
func (*FileState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *FileState) GetState() State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return State_ERROR
}

// *
// Request to get part of a file to read
type ReadRequest struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Start            *int64  `protobuf:"varint,2,req,name=start" json:"start,omitempty"`
	Size             *int64  `protobuf:"varint,3,req,name=size" json:"size,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ReadRequest) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ReadRequest) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *ReadRequest) GetSize() int64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func init() {
	proto.RegisterType((*Task)(nil), "agro_pb.Task")
	proto.RegisterType((*Job)(nil), "agro_pb.Job")
	proto.RegisterType((*JobStatus)(nil), "agro_pb.JobStatus")
	proto.RegisterType((*TaskStatus)(nil), "agro_pb.TaskStatus")
	proto.RegisterType((*CmdArgument)(nil), "agro_pb.CmdArgument")
	proto.RegisterType((*FileArgument)(nil), "agro_pb.FileArgument")
	proto.RegisterType((*TagArray)(nil), "agro_pb.TagArray")
	proto.RegisterType((*IDQuery)(nil), "agro_pb.IDQuery")
	proto.RegisterType((*DataBlock)(nil), "agro_pb.DataBlock")
	proto.RegisterType((*FileInfo)(nil), "agro_pb.FileInfo")
	proto.RegisterType((*FileID)(nil), "agro_pb.FileID")
	proto.RegisterType((*FileState)(nil), "agro_pb.FileState")
	proto.RegisterType((*ReadRequest)(nil), "agro_pb.ReadRequest")
	proto.RegisterEnum("agro_pb.State", State_name, State_value)
	proto.RegisterEnum("agro_pb.FileArgument_FileArgType", FileArgument_FileArgType_name, FileArgument_FileArgType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Scheduler service

type SchedulerClient interface {
	SearchTasks(ctx context.Context, in *TagArray, opts ...grpc.CallOption) (Scheduler_SearchTasksClient, error)
	AddTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*TaskStatus, error)
	GetTaskStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetTaskStatusClient, error)
	GetJobStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetJobStatusClient, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) SearchTasks(ctx context.Context, in *TagArray, opts ...grpc.CallOption) (Scheduler_SearchTasksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[0], c.cc, "/agro_pb.Scheduler/SearchTasks", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerSearchTasksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_SearchTasksClient interface {
	Recv() (*Task, error)
	grpc.ClientStream
}

type schedulerSearchTasksClient struct {
	grpc.ClientStream
}

func (x *schedulerSearchTasksClient) Recv() (*Task, error) {
	m := new(Task)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) AddTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*TaskStatus, error) {
	out := new(TaskStatus)
	err := grpc.Invoke(ctx, "/agro_pb.Scheduler/AddTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) GetTaskStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetTaskStatusClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[1], c.cc, "/agro_pb.Scheduler/GetTaskStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerGetTaskStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_GetTaskStatusClient interface {
	Recv() (*TaskStatus, error)
	grpc.ClientStream
}

type schedulerGetTaskStatusClient struct {
	grpc.ClientStream
}

func (x *schedulerGetTaskStatusClient) Recv() (*TaskStatus, error) {
	m := new(TaskStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) GetJobStatus(ctx context.Context, in *IDQuery, opts ...grpc.CallOption) (Scheduler_GetJobStatusClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[2], c.cc, "/agro_pb.Scheduler/GetJobStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerGetJobStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_GetJobStatusClient interface {
	Recv() (*JobStatus, error)
	grpc.ClientStream
}

type schedulerGetJobStatusClient struct {
	grpc.ClientStream
}

func (x *schedulerGetJobStatusClient) Recv() (*JobStatus, error) {
	m := new(JobStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Scheduler service

type SchedulerServer interface {
	SearchTasks(*TagArray, Scheduler_SearchTasksServer) error
	AddTask(context.Context, *Task) (*TaskStatus, error)
	GetTaskStatus(*IDQuery, Scheduler_GetTaskStatusServer) error
	GetJobStatus(*IDQuery, Scheduler_GetJobStatusServer) error
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_SearchTasks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagArray)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).SearchTasks(m, &schedulerSearchTasksServer{stream})
}

type Scheduler_SearchTasksServer interface {
	Send(*Task) error
	grpc.ServerStream
}

type schedulerSearchTasksServer struct {
	grpc.ServerStream
}

func (x *schedulerSearchTasksServer) Send(m *Task) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_AddTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SchedulerServer).AddTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Scheduler_GetTaskStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IDQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).GetTaskStatus(m, &schedulerGetTaskStatusServer{stream})
}

type Scheduler_GetTaskStatusServer interface {
	Send(*TaskStatus) error
	grpc.ServerStream
}

type schedulerGetTaskStatusServer struct {
	grpc.ServerStream
}

func (x *schedulerGetTaskStatusServer) Send(m *TaskStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_GetJobStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IDQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).GetJobStatus(m, &schedulerGetJobStatusServer{stream})
}

type Scheduler_GetJobStatusServer interface {
	Send(*JobStatus) error
	grpc.ServerStream
}

type schedulerGetJobStatusServer struct {
	grpc.ServerStream
}

func (x *schedulerGetJobStatusServer) Send(m *JobStatus) error {
	return x.ServerStream.SendMsg(m)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agro_pb.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTask",
			Handler:    _Scheduler_AddTask_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchTasks",
			Handler:       _Scheduler_SearchTasks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTaskStatus",
			Handler:       _Scheduler_GetTaskStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetJobStatus",
			Handler:       _Scheduler_GetJobStatus_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for FileStore service

type FileStoreClient interface {
	CreateFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileState, error)
	WriteFile(ctx context.Context, in *DataBlock, opts ...grpc.CallOption) (*FileState, error)
	CommitFile(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error)
	GetFileInfo(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileInfo, error)
	ReadFile(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*DataBlock, error)
}

type fileStoreClient struct {
	cc *grpc.ClientConn
}

func NewFileStoreClient(cc *grpc.ClientConn) FileStoreClient {
	return &fileStoreClient{cc}
}

func (c *fileStoreClient) CreateFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/CreateFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) WriteFile(ctx context.Context, in *DataBlock, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/WriteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) CommitFile(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileState, error) {
	out := new(FileState)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/CommitFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) GetFileInfo(ctx context.Context, in *FileID, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/GetFileInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStoreClient) ReadFile(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*DataBlock, error) {
	out := new(DataBlock)
	err := grpc.Invoke(ctx, "/agro_pb.FileStore/ReadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileStore service

type FileStoreServer interface {
	CreateFile(context.Context, *FileInfo) (*FileState, error)
	WriteFile(context.Context, *DataBlock) (*FileState, error)
	CommitFile(context.Context, *FileID) (*FileState, error)
	GetFileInfo(context.Context, *FileID) (*FileInfo, error)
	ReadFile(context.Context, *ReadRequest) (*DataBlock, error)
}

func RegisterFileStoreServer(s *grpc.Server, srv FileStoreServer) {
	s.RegisterService(&_FileStore_serviceDesc, srv)
}

func _FileStore_CreateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).CreateFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).WriteFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_CommitFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).CommitFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_GetFileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FileID)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).GetFileInfo(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileStore_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileStoreServer).ReadFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _FileStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agro_pb.FileStore",
	HandlerType: (*FileStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFile",
			Handler:    _FileStore_CreateFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FileStore_WriteFile_Handler,
		},
		{
			MethodName: "CommitFile",
			Handler:    _FileStore_CommitFile_Handler,
		},
		{
			MethodName: "GetFileInfo",
			Handler:    _FileStore_GetFileInfo_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FileStore_ReadFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 797 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x8e, 0xed, 0x24, 0xb6, 0x27, 0x3f, 0x75, 0x97, 0x16, 0x59, 0x95, 0x90, 0x8a, 0x4f, 0xa5,
	0x87, 0x16, 0xa5, 0x6a, 0x85, 0x38, 0xe1, 0x36, 0xa1, 0x0d, 0x3f, 0x69, 0x9b, 0x1f, 0xca, 0x01,
	0x29, 0x72, 0xe3, 0x6d, 0x6a, 0x92, 0xd8, 0x61, 0x6d, 0x1f, 0xc2, 0xab, 0x20, 0x1e, 0x80, 0x77,
	0xe2, 0xce, 0x6b, 0x30, 0x6b, 0xc7, 0x8e, 0x43, 0x52, 0x24, 0x24, 0x6e, 0xb3, 0xb3, 0xf3, 0x7d,
	0xfb, 0xcd, 0x37, 0x63, 0x83, 0x36, 0x65, 0x5e, 0xe0, 0x1d, 0x5a, 0x43, 0xe6, 0x1d, 0x44, 0x21,
	0x91, 0x79, 0xdc, 0x9f, 0xde, 0x1a, 0xdf, 0x05, 0xc8, 0x77, 0x2d, 0x7f, 0x44, 0x00, 0x44, 0xc7,
	0xd6, 0x85, 0x5d, 0x71, 0x4f, 0x25, 0x5b, 0x50, 0x0e, 0x30, 0xd7, 0xb7, 0xe9, 0x94, 0xba, 0xb6,
	0xaf, 0x8b, 0xbb, 0x12, 0x66, 0x37, 0x40, 0x1e, 0x78, 0x93, 0x89, 0xe5, 0xda, 0xba, 0x14, 0x95,
	0x19, 0x90, 0xb7, 0xd8, 0xd0, 0xd7, 0xf3, 0x78, 0x5d, 0xaa, 0x6d, 0x1d, 0xcc, 0x39, 0x0f, 0xce,
	0x26, 0xb6, 0xc9, 0x86, 0xe1, 0x84, 0xba, 0x01, 0xd9, 0x04, 0x75, 0xe0, 0xb9, 0x81, 0xe5, 0xb8,
	0x94, 0xe9, 0x85, 0x5d, 0x01, 0x61, 0x65, 0xc8, 0x07, 0x16, 0xc2, 0x8a, 0x11, 0xeb, 0x13, 0x28,
	0xf8, 0x81, 0x15, 0x50, 0x5d, 0xc6, 0xcb, 0x6a, 0xad, 0x9a, 0xb2, 0x74, 0x78, 0xd6, 0xf8, 0x21,
	0x80, 0xf4, 0xc6, 0xbb, 0x5d, 0x92, 0x87, 0x42, 0x22, 0x79, 0x98, 0x10, 0x93, 0xc4, 0x7f, 0x51,
	0x96, 0x6a, 0x29, 0x22, 0xcb, 0x8a, 0x16, 0x52, 0x85, 0xa2, 0x1f, 0xd8, 0x5e, 0x18, 0xa0, 0x56,
	0xfe, 0x4a, 0x7c, 0xa6, 0x8c, 0xe9, 0x0a, 0x3f, 0x1b, 0x27, 0xa0, 0xa2, 0x54, 0x5e, 0x1b, 0xfa,
	0x4b, 0x82, 0x53, 0x5e, 0x71, 0x1d, 0xaf, 0xf1, 0x09, 0x80, 0x8f, 0xe0, 0x9f, 0x81, 0x64, 0x1b,
	0x2a, 0xd8, 0xf7, 0x74, 0x4c, 0x03, 0x6a, 0xf7, 0x3f, 0x7b, 0xb7, 0xd8, 0xfd, 0xdc, 0x60, 0x16,
	0xba, 0x71, 0xf7, 0xaa, 0x71, 0x05, 0xa5, 0x6c, 0xdb, 0x15, 0x90, 0xd0, 0x1a, 0xe4, 0xc7, 0xca,
	0x8b, 0x1c, 0x79, 0x06, 0xca, 0x9d, 0x33, 0xa6, 0x7d, 0x9e, 0x13, 0x31, 0x57, 0xaa, 0x6d, 0xa7,
	0x8f, 0xbc, 0xc6, 0x8b, 0x04, 0x77, 0x91, 0x3b, 0x95, 0xa1, 0xf0, 0xc1, 0x1a, 0x87, 0xd4, 0xf8,
	0x29, 0x40, 0x39, 0x7b, 0xb7, 0x24, 0xb9, 0x02, 0x05, 0xc7, 0x9d, 0xa2, 0x47, 0x5c, 0xb2, 0x42,
	0x0e, 0x71, 0xd8, 0xb3, 0x29, 0x8d, 0xe6, 0x52, 0xad, 0x3d, 0x5d, 0xcb, 0x9d, 0x1c, 0xba, 0x58,
	0xc8, 0xc5, 0xbb, 0xd6, 0x84, 0xa2, 0x78, 0xde, 0x8a, 0x06, 0x0a, 0x3f, 0xf5, 0x47, 0x74, 0x36,
	0x9f, 0x11, 0x37, 0x1d, 0xcb, 0xdd, 0x00, 0x87, 0x24, 0xec, 0x29, 0xbc, 0xbd, 0x2c, 0x5c, 0x81,
	0xfc, 0x95, 0xd9, 0xbd, 0xd0, 0x04, 0xa2, 0x42, 0xa1, 0x65, 0xbe, 0x6f, 0xd4, 0x35, 0x91, 0x87,
	0xed, 0xc6, 0x79, 0xe3, 0xa3, 0x26, 0xa1, 0xd4, 0x62, 0xa7, 0x5b, 0xbf, 0xec, 0x75, 0xb5, 0xfc,
	0x3c, 0x6e, 0xb4, 0xdb, 0x5a, 0x81, 0x97, 0x60, 0xdc, 0x6c, 0x69, 0x45, 0x43, 0x07, 0xa5, 0x6b,
	0x0d, 0x4d, 0xc6, 0xac, 0x59, 0xba, 0xab, 0x42, 0x64, 0xe5, 0x63, 0x90, 0x9b, 0xf5, 0xeb, 0x90,
	0xb2, 0x19, 0x29, 0x81, 0xe4, 0xd8, 0x49, 0xde, 0x04, 0xb5, 0x6e, 0x05, 0xd6, 0xe9, 0xd8, 0x1b,
	0x8c, 0xfe, 0x34, 0x03, 0xe7, 0xc7, 0x62, 0x33, 0x24, 0x0e, 0x42, 0xe5, 0x91, 0x17, 0x12, 0xa7,
	0xb6, 0x11, 0x84, 0x8d, 0x8a, 0x7b, 0x65, 0xe3, 0x15, 0x28, 0xbc, 0x8d, 0xa6, 0x7b, 0xe7, 0xa5,
	0x16, 0xc4, 0x1c, 0x31, 0x5f, 0xbc, 0xe8, 0x78, 0xe3, 0x3b, 0x5f, 0x69, 0x34, 0xe7, 0x88, 0x21,
	0x64, 0xe3, 0x64, 0xce, 0x5b, 0x50, 0x8c, 0x18, 0xea, 0x59, 0x05, 0xc6, 0x3e, 0xa8, 0x3c, 0x1b,
	0xef, 0x4b, 0xba, 0x4e, 0xc2, 0xda, 0x3d, 0x3c, 0x81, 0x52, 0x9b, 0x5a, 0x76, 0x9b, 0x7e, 0x09,
	0xa9, 0x1f, 0xfc, 0xad, 0x91, 0x85, 0x0e, 0x3c, 0xed, 0xbf, 0x43, 0xef, 0x22, 0x7e, 0x34, 0x11,
	0xdd, 0xbc, 0x6c, 0x6b, 0x39, 0x6c, 0x55, 0xbe, 0x31, 0x9b, 0xdd, 0x66, 0xeb, 0x1c, 0x47, 0x81,
	0x46, 0x5f, 0xf7, 0x1a, 0xbd, 0x68, 0x16, 0x18, 0x5f, 0x99, 0xbd, 0x0e, 0xc6, 0xdc, 0x0f, 0xb9,
	0xdd, 0x6b, 0xb5, 0x78, 0x51, 0x9e, 0x14, 0x41, 0xbc, 0x7c, 0xab, 0x15, 0x6a, 0xbf, 0x04, 0x50,
	0x3b, 0x83, 0x7b, 0x6a, 0x87, 0x63, 0xca, 0xc8, 0x11, 0x94, 0x3a, 0xd4, 0x62, 0x83, 0x7b, 0xfe,
	0x85, 0xf8, 0x64, 0x33, 0x95, 0x9c, 0x8c, 0x68, 0xa7, 0x92, 0x49, 0xf9, 0x23, 0x23, 0xf7, 0x5c,
	0xc0, 0xa5, 0x93, 0x4d, 0xdb, 0x8e, 0x7e, 0x6b, 0xcb, 0xb7, 0x3b, 0x8f, 0x96, 0x8e, 0xf1, 0x17,
	0x67, 0xe4, 0xc8, 0x4b, 0xa8, 0x9c, 0xd3, 0x20, 0xf3, 0x11, 0x6a, 0x69, 0xdd, 0x7c, 0xe0, 0x0f,
	0x20, 0xf1, 0xb1, 0x17, 0x50, 0x46, 0xec, 0xe2, 0xc3, 0x5f, 0x85, 0x92, 0x34, 0x93, 0x56, 0x71,
	0x64, 0xed, 0x9b, 0x98, 0x0c, 0xc7, 0x63, 0x94, 0x1c, 0x03, 0x9c, 0x31, 0x8a, 0x36, 0xf2, 0x54,
	0xa6, 0xd1, 0x64, 0x2d, 0x32, 0x34, 0xe9, 0x44, 0x51, 0xfa, 0x31, 0xa8, 0x37, 0xcc, 0x99, 0xa3,
	0x16, 0x25, 0xe9, 0x3e, 0x3e, 0x00, 0x3b, 0xc2, 0xd7, 0xf0, 0x97, 0xe9, 0x04, 0x11, 0x6e, 0x63,
	0xf9, 0xb5, 0xfa, 0x83, 0xa0, 0x12, 0xb6, 0x9a, 0xee, 0xe9, 0x0a, 0x6a, 0x55, 0x34, 0x82, 0x4e,
	0x40, 0xe1, 0x5b, 0x15, 0xbd, 0xb3, 0xf8, 0x13, 0x67, 0x16, 0x6d, 0x67, 0x8d, 0x6a, 0x23, 0xf7,
	0x3b, 0x00, 0x00, 0xff, 0xff, 0xbd, 0xb9, 0xee, 0xf0, 0xb5, 0x06, 0x00, 0x00,
}
